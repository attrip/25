<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script>
    // 初期描画前にテーマ属性を設定してFOUCを抑制
    (function(){
      try {
        var KEY = 'focus_theme_v1_theme';
        var t = localStorage.getItem(KEY);
        if (!t && window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) t = 'light';
        if (t === 'light') document.documentElement.setAttribute('data-theme', 'light');
      } catch (e) {}
    })();
  </script>
  <title>25分集中ミニアプリ</title>
  <style>
    :root {
      --bg: #0b1220;
      --fg: #e5e7eb;
      --muted: #94a3b8;
      --border: rgba(148, 163, 184, 0.22);
      --surface: rgba(15, 23, 42, 0.5);
      --accent: #60a5fa; /* blue-400 */
      --ring: rgba(96, 165, 250, 0.35);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN", "Yu Gothic", Meiryo, sans-serif;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.5;
    }
    body::before { content: none; }
    body::after { content: none; }
    .container {
      max-width: 820px;
      padding: 24px;
      margin: 0 auto;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
    }
    .brand { display: flex; align-items: center; gap: 10px; }
    .brand svg { flex: none; opacity: .9; color: var(--accent); }
    .brand a { color: inherit; text-decoration: none; }
    h1 { font-size: 18px; margin: 0; color: #e5e7eb; letter-spacing: .01em; font-weight: 600; }
    .badge {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 3px 8px; border-radius: 999px;
      background: rgba(148,163,184,0.12);
      border: 1px solid rgba(148,163,184,0.32);
      color: rgba(226,232,240,0.85);
      font-size: 11px; letter-spacing: .08em; text-transform: uppercase;
      backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
      transition: background .2s ease, border-color .2s ease, color .2s ease;
    }
    .screen { display: none; }
    .screen.active { display: block; }
    .card { background: rgba(15,23,42,0.48); border: 1px solid var(--border); border-radius: 14px; padding: 18px; position: relative; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .spacer { height: 12px; }
    .timer { font-variant-numeric: tabular-nums; font-size: 60px; letter-spacing: .02em; text-align: center; margin: 8px 0 12px; font-weight: 700; color: var(--fg); }
    #saveStatus { font-variant-numeric: tabular-nums; }
    .muted { color: var(--muted); }
    button, .button-like { appearance: none; border: 1px solid rgba(148, 163, 184, 0.28); background: rgba(148, 163, 184, 0.06); color: var(--fg); padding: 10px 14px; border-radius: 12px; font-size: 14px; cursor: pointer; transition: background .15s ease, border-color .15s ease, box-shadow .15s ease; }
    button:hover { background: rgba(148, 163, 184, 0.10); }
    button:focus-visible { outline: none; box-shadow: 0 0 0 3px var(--ring); }
    button.primary { border-color: rgba(96,165,250,.5); background: rgba(96,165,250,.14); }
    button.primary:hover { background: rgba(96,165,250,.18); }
    button.warn, button.danger { border-color: var(--border); background: rgba(148, 163, 184, 0.08); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    textarea { width: 100%; min-height: 44vh; resize: vertical; padding: 12px; border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.28); background: #0b1322; color: var(--fg); font-size: 16px; line-height: 1.6; transition: border-color .15s ease, box-shadow .15s ease, background .15s ease; }
    textarea:focus { outline: none; border-color: rgba(96,165,250,.55); box-shadow: 0 0 0 3px rgba(96,165,250,.22); background: #0d1526; }
    textarea::placeholder { color: rgba(148, 163, 184, 0.7); }
    ul.list { list-style: none; padding: 0; margin: 0; }
    ul.list li { padding: 10px 12px; border: 1px solid rgba(148,163,184,0.22); background: rgba(148,163,184,0.04); border-radius: 12px; margin-bottom: 8px; transition: border-color .15s ease, background .15s ease; }
    ul.list li:hover { border-color: rgba(96,165,250,.35); background: rgba(148,163,184,0.06); }
    /* Entry card layout */
    ul.list li.entry-card { position: relative; display: block; padding: 16px; padding-right: 120px; }
    .title-btn { appearance: none; background: transparent; border: none; color: inherit; padding: 0; margin: 0; font: inherit; font-weight: 700; cursor: pointer; }
    .title-btn:hover { text-decoration: none; color: var(--accent); }
    .title-btn:focus-visible { outline: none; box-shadow: 0 0 0 3px var(--ring); border-radius: 6px; }
    .entry-title { font-weight: 700; margin-bottom: 4px; }
    .entry-meta { font-size: 12px; margin-bottom: 6px; }
    .entry-preview { font-size: 13px; color: var(--muted); }
    .entry-actions { position: absolute; top: 8px; right: 16px; display: flex; gap: 8px; align-items: center; justify-content: flex-end; }
    .icon-btn { appearance: none; border: none; background: transparent; color: var(--muted); padding: 4px 8px; border-radius: 8px; cursor: pointer; }
    .icon-btn:hover { background: rgba(148,163,184,0.12); }
    .star-btn { position: static; font-size: 18px; }
    .star-btn.is-starred { color: #fbbf24; }
    .del-btn { position: static; border: 1px solid rgba(239,68,68,0.45); background: rgba(239,68,68,0.12); color: #fecaca; padding: 6px 8px; border-radius: 8px; }
    .del-btn:hover { background: rgba(239,68,68,0.18); }
    .ghost { opacity: 0.7; }
    .focus-msg {
      text-align: center;
      font-weight: 600;
      letter-spacing: .02em;
      color: #f5f5f5;
    }
    .toast {
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%) translateY(8px) scale(0.98);
      opacity: 0;
      visibility: hidden;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(96,165,250,0.12);
      color: var(--fg);
      z-index: 1000;
      pointer-events: none;
      transition: opacity .22s ease, transform .22s ease, visibility 0s linear .22s;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }
    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0) scale(1);
      visibility: visible;
      transition-delay: 0s, 0s, 0s;
    }

    /* Gentle coach tip */
    .coach { position: absolute; right: 16px; bottom: 16px; padding: 6px 10px; border-radius: 10px; border: 1px solid var(--border); color: var(--muted); background: rgba(148,163,184,0.06); font-size: 13px; letter-spacing: .01em; pointer-events: none; }

    /* Search and chips */
    input[type="search"] { appearance: none; border: 1px solid var(--border); background: rgba(148,163,184,0.06); color: var(--fg); padding: 10px 12px; border-radius: 10px; font-size: 14px; }
    input[type="search"]::placeholder { color: rgba(148,163,184,0.6); }
    .chips { display: flex; gap: 6px; flex-wrap: wrap; }
    #chatRow { display: flex; gap: 12px; align-items: center; flex-wrap: nowrap; width: 100%; }
    #chatSend { flex: none; }
    #chatInput { appearance: none; border: 1px solid var(--border); background: rgba(148,163,184,0.08); color: var(--fg); padding: 12px 14px; border-radius: 12px; font-size: 20px; line-height: 1.8; flex: 1 1 auto; min-width: 0; }
    .chip { display: inline-flex; align-items: center; gap: 6px; border: 1px solid var(--border); color: var(--fg); background: rgba(148,163,184,0.06); border-radius: 999px; padding: 4px 8px; font-size: 12px; cursor: pointer; }
    .chip.active { border-color: rgba(96,165,250,.5); background: rgba(96,165,250,.12); }

    /* Purpose input (bigger, more prominent) */
    #purposeInput { appearance: none; border: 1px solid var(--border); background: rgba(148,163,184,0.08); color: var(--fg); padding: 12px 14px; border-radius: 12px; font-size: 18px; line-height: 1.4; }
    #purposeInput::placeholder { color: rgba(148,163,184,0.7); }
    #purposeInput:focus { outline: none; box-shadow: 0 0 0 3px var(--ring); border-color: rgba(96,165,250,.55); background: rgba(148,163,184,0.10); }

    /* Footer links */
    .footer { margin-top: 20px; padding-top: 12px; border-top: 1px solid var(--border); text-align: center; color: var(--muted); font-size: 12px; }
    .footer .links { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-top: 6px; }
    .footer a { display: inline-flex; align-items: center; gap: 6px; text-decoration: none; color: var(--fg); border: 1px solid var(--border); background: rgba(148,163,184,0.06); padding: 6px 10px; border-radius: 999px; font-size: 12px; }
    .footer .copy { margin-top: 10px; }

    /* Readable modal */
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
    .modal.show { display: flex; }
    .modal-panel { width: min(880px, 92vw); max-height: 86vh; overflow: auto; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 16px; color: var(--fg); }
    .read-controls { display: flex; gap: 8px; align-items: center; justify-content: space-between; margin-bottom: 8px; }
    .read-controls .left, .read-controls .right { display: flex; gap: 8px; align-items: center; }
    .readable { max-width: 72ch; margin: 0 auto; font-size: 18px; line-height: 1.85; letter-spacing: .01em; }
    .readable p { margin: .7em 0; }
    .readable a { color: var(--accent); text-decoration: underline; text-underline-offset: 2px; }
    .read-empty { text-align: center; color: var(--muted); padding: 32px 0; }

    html[data-theme="light"] .modal-panel { background: var(--surface); border-color: var(--border); }

    /* Mic quick-start overlay */
    .mic-overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.35); backdrop-filter: blur(2px); border-radius: 12px; }
    .mic-panel { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 16px; text-align: center; min-width: min(420px, 92%); }
    .mic-title { font-weight: 700; margin-bottom: 8px; }
    .mic-hint { font-size: 12px; margin-top: 6px; }
    html[data-theme="light"] .mic-panel { background: var(--surface); border-color: var(--border); }

    /* Light theme overrides (htmlにdata-themeを付与) */
    html[data-theme="light"] body {
      --bg: #f8fafc;
      --fg: #0f172a;
      --muted: #475569;
      --border: rgba(15, 23, 42, 0.14);
      --surface: rgba(255, 255, 255, 0.82);
      --ring: rgba(96,165,250, 0.28);
      background: #f8fafc;
      color: var(--fg);
    }
    html[data-theme="light"] h1 { color: #0f172a; }
    html[data-theme="light"] .muted { color: #64748b; }
    html[data-theme="light"] .card { background: var(--surface); border-color: var(--border); }
    html[data-theme="light"] .badge { background: rgba(15,23,42,0.06); border-color: rgba(15,23,42,0.18); color: rgba(15,23,42,0.8); }
    html[data-theme="light"] button:not(.primary):not(.warn):not(.danger),
    html[data-theme="light"] .button-like { border-color: rgba(15,23,42,0.18); background: rgba(2,6,23,0.04); color: #0f172a; }
    html[data-theme="light"] textarea { background: #ffffff; color: #0f172a; border-color: rgba(15,23,42,0.18); }
    html[data-theme="light"] ul.list li { border-color: rgba(15,23,42,0.14); background: rgba(2,6,23,0.04); }
    html[data-theme="light"] .focus-msg { color: #0f172a; }
    html[data-theme="light"] .toast { background: rgba(96,165,250,0.12); color: var(--fg); border-color: rgba(96,165,250,0.28); }

    /* Fullscreen mode */
    body.body-fullscreen .container {
      max-width: 100%;
      height: 100%;
      padding: 0;
    }
    body.body-fullscreen header,
    body.body-fullscreen footer,
    body.body-fullscreen #screen-home,
    body.body-fullscreen #screen-break,
    body.body-fullscreen #screen-work .row,
    body.body-fullscreen #screen-work .timer,
    body.body-fullscreen #screen-work .focus-msg,
    body.body-fullscreen #screen-work .muted,
    body.body-fullscreen #screen-work .spacer,
    body.body-fullscreen #micStatus,
    body.body-fullscreen #micInterim,
    body.body-fullscreen #coach,
    body.body-fullscreen #micOverlay {
      display: none !important;
    }
    body.body-fullscreen #screen-work,
    body.body-fullscreen #screen-work .card {
      height: 100%;
      padding: 0;
      border: none;
      border-radius: 0;
    }
    body.body-fullscreen #editor {
      height: 100vh;
      border-radius: 0;
      border: none;
      font-size: 20px; /* Increase font size in fullscreen */
    }

    /* Reduced motion respect */
    @media (prefers-reduced-motion: reduce) { * { animation: none !important; transition: none !important; } }
  </style>
  <meta name="description" content="25分集中 + 5分休憩を回す、ローカル保存対応のシンプルな集中支援アプリ" />
</head>
<body>
  <div class="container">
    <header>
      <div class="brand">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <circle cx="12" cy="12" r="8.5" stroke="currentColor" stroke-opacity="0.55" stroke-width="1.2" />
          <circle cx="9.2" cy="9.2" r="1.2" fill="currentColor" />
        </svg>
        <h1><a id="brandHome" href="#" title="ホームへ">25分集中ミニアプリ</a></h1>
        <span class="badge">BETA</span>
      </div>
      <div class="row">
        <button id="btnTheme" title="ダーク/ライト切替" aria-label="テーマ切替">🌗 テーマ</button>
      </div>
    </header>

    <!-- ホーム画面 -->
    <section id="screen-home" class="screen active">
      <div class="card">
        <div class="row">
          <input id="purposeInput" type="text" placeholder="一行で今日の目的を書く（例: 仕様書の初稿を仕上げる）" style="flex:1; min-width: 260px;" />
          <button id="btnStart" class="primary">25分を開始</button>
        </div>
        <div class="spacer"></div>
        <div class="row" id="modeChips">
          <span class="muted">集中モード:</span>
          <button id="mode5" class="chip" title="5分モード">5分</button>
          <button id="mode15" class="chip" title="15分モード">15分</button>
          <button id="mode25" class="chip active" title="25分モード">25分</button>
        </div>
        <div class="spacer"></div>
        <div class="row" style="align-items:flex-start; gap: 10px;">
          <span class="muted" style="margin-top: 8px;">お知らせ:</span>
          <label class="muted" style="display:flex; gap:6px; align-items:center;"><input type="checkbox" id="oneMinAlert" /> 1分前に音声でお知らせ</label>
        </div>
        <div class="spacer"></div>
        <div class="row">
          <input id="searchInput" type="search" placeholder="検索（タイトル・本文・#タグ）" style="flex:1; min-width: 240px;">
          <button id="btnStarFilter" title="スターのみ切替">☆ すべて</button>
        </div>
        <div class="spacer"></div>
        <div id="tagChips" class="chips"></div>
        <div class="spacer"></div>
        <div class="muted">過去の保存テキスト</div>
        <ul id="listSaved" class="list"></ul>
        <div id="emptySaved" class="muted ghost">まだ保存されたテキストはありません。</div>
      </div>
    </section>

    <!-- 作業画面 -->
    <section id="screen-work" class="screen">
      <div class="card">
        <div class="timer" id="timerWork">00:00</div>
        <div class="focus-msg" aria-live="polite">今は書くことだけ</div>
        <div id="calmMsg" class="muted" aria-live="polite" style="text-align:center; font-size:13px; margin-top:4px;">残り --:-- — 深呼吸して続けよう</div>
        <div id="metrics" class="muted" aria-live="polite" style="text-align:center; font-size:12px; margin-top:4px;">文字数 0 | WPM 0</div>
        <div class="spacer"></div>
        <textarea id="editor" placeholder="今考えていることを、そのまま書き始めましょう。装飾や整形は後で大丈夫です。"></textarea>
        <div class="spacer"></div>
        <div class="row" id="chatRow">
          <input id="chatInput" type="text" placeholder="ここに1行入力してEnterで追記" />
          <button id="chatSend" class="primary">追加</button>
        </div>
        <div class="spacer"></div>
        <div class="row">
          <button id="btnSave" class="primary">保存</button>
          <button id="btnPause" class="warn">一時停止</button>
          <button id="btnReset" class="danger">リセット</button>
          <button id="btnMic" title="音声入力">🎤 音声入力開始</button>
          <button id="btnFullscreen" title="集中モード切替">集中モード</button>
          <span id="saveStatus" class="muted" style="margin-left: auto;"></span>
        </div>
        <div class="spacer"></div>
        <div id="micStatus" class="muted" style="display:none">音声入力中…</div>
        <div id="micInterim" class="muted" style="display:none"></div>
        <div id="coach" class="coach" style="display:none" aria-live="polite"></div>
        <div id="micOverlay" class="mic-overlay" aria-hidden="true">
          <div class="mic-panel">
            <div class="mic-title">音声入力</div>
            <button id="micOverlayStart" class="primary" style="min-width:200px; font-size:16px;">🎤 音声入力を開始</button>
            <div style="margin-top:8px; display:flex; gap:8px; align-items:center; justify-content:center;">
              <label class="muted" style="display:flex; gap:6px; align-items:center;"><input type="checkbox" id="micAuto" /> 次回から自動で開始</label>
              <label class="muted" style="display:flex; gap:6px; align-items:center;"><input type="checkbox" id="micPersist" /> 自動再開を維持</label>
            </div>
            <div class="mic-hint muted">ブラウザの許可ポップアップで「常に許可」にすると次回スムーズです</div>
          </div>
        </div>
      </div>
    </section>

    <!-- 休憩画面 -->
    <section id="screen-break" class="screen">
      <div class="card">
        <div class="timer" id="timerBreak">05:00</div>
        <div class="focus-msg muted" aria-live="polite">肩の力を抜いてリラックス</div>
        <div class="spacer"></div>
        <div class="row">
          <button id="btnSkipBreak" class="warn">休憩をスキップ</button>
          <button id="btnBackHome">ホームへ</button>
        </div>
      </div>
    </section>
  </div>

  <!-- 読みやすさモード -->
  <div id="readModal" class="modal" role="dialog" aria-modal="true" aria-label="読みやすさモード">
    <div class="modal-panel">
      <div class="read-controls">
        <div class="left">
          <strong class="muted">読む</strong>
        </div>
        <div class="right">
          <button id="readDec" title="文字サイズを小さく">A-</button>
          <button id="readInc" title="文字サイズを大きく">A+</button>
          <button id="readLh" title="行間を切替">行間</button>
          <button id="readClose" class="danger" title="閉じる">閉じる</button>
        </div>
      </div>
      <article id="readContent" class="readable"></article>
      <div id="readEmpty" class="read-empty" style="display:none">表示するテキストがありません</div>
    </div>
  </div>

  <!-- 達成ダイアログ（静かなメッセージ） -->
  <div id="celebrate" class="modal" role="dialog" aria-modal="true" aria-label="達成おめでとう" style="display:none;">
    <div class="modal-panel" style="position:relative; overflow:hidden; text-align:center;">
      <div id="celebrateTitle" style="font-size:20px; font-weight:700; margin:6px 0;">よく頑張った！</div>
      <div id="celebrateBody" class="muted" style="margin-bottom:8px;">集中、お疲れさま。</div>
      <button id="celebrateClose">閉じる</button>
    </div>
  </div>

  <footer class="footer" role="contentinfo">
    <div class="muted">外部AIツール</div>
    <div class="links">
      <a href="https://chat.openai.com/" target="_blank" rel="noopener noreferrer" title="ChatGPT を開く">ChatGPT</a>
      <a href="https://gemini.google.com/" target="_blank" rel="noopener noreferrer" title="Gemini を開く">Gemini</a>
    </div>
    <div class="copy muted">© <a href="https://attrip.jp" target="_blank" rel="noopener noreferrer" title="attrip">attrip</a></div>
  </footer>

  <div id="toast" class="toast" role="status" aria-live="polite">1ターム完了！お疲れさまでした。</div>

  <script>
    // 設定
    // 集中モード（5 / 15 / 25分）
    const MODE_KEY = 'focus_mode_minutes_v1';
    const mode5Btn = document.getElementById('mode5');
    const mode15Btn = document.getElementById('mode15');
    const mode25Btn = document.getElementById('mode25');
    let workMinutes = (() => { try { return parseInt(localStorage.getItem(MODE_KEY)||'25',10)||25; } catch { return 25; } })();
    function updateModeUI() {
      if (mode5Btn && mode15Btn && mode25Btn) {
        mode5Btn.classList.toggle('active', workMinutes === 5);
        mode15Btn.classList.toggle('active', workMinutes === 15);
        mode25Btn.classList.toggle('active', workMinutes === 25);
      }
      const btn = document.getElementById('btnStart');
      if (btn) btn.textContent = `${workMinutes}分を開始`;
      const brand = document.getElementById('brandHome');
      if (brand) brand.textContent = `${workMinutes}分集中ミニアプリ`;
      try { document.title = `${workMinutes}分集中ミニアプリ`; } catch {}
      // プレビューのタイマー/メッセージも選択中の分数に揃える（作業中は触らない）
      try {
        if (typeof state === 'undefined' || state !== 'work') {
          const previewSec = (DEV ? 25 : workMinutes * 60);
          const tw = document.getElementById('timerWork');
          if (tw) tw.textContent = fmt(previewSec);
          const cm = document.getElementById('calmMsg');
          if (cm) cm.textContent = `残り ${fmt(previewSec)} — 深呼吸して続けよう`;
        }
      } catch {}
    }
    if (mode5Btn) mode5Btn.onclick = () => { workMinutes = 5; try{localStorage.setItem(MODE_KEY,'5');}catch{} updateModeUI(); };
    if (mode15Btn) mode15Btn.onclick = () => { workMinutes = 15; try{localStorage.setItem(MODE_KEY,'15');}catch{} updateModeUI(); };
    if (mode25Btn) mode25Btn.onclick = () => { workMinutes = 25; try{localStorage.setItem(MODE_KEY,'25');}catch{} updateModeUI(); };
    const BREAK_MIN = 5;
    // 開発確認を早めに: URLに ?dev=1 で 25秒/5秒 に短縮
    const qs = new URLSearchParams(location.search);
    const DEV = qs.get('dev') === '1';
    const BREAK_SEC = DEV ? 5 : BREAK_MIN * 60;
    // アラート関連（設定＆しきい値）
    const ALERT_TEST = qs.get('alerttest') === '1';
    const ONE_MIN_ALERT_THRESHOLD = ALERT_TEST ? 5 : 60; // 隠しテストモードで短縮
    const ONE_MIN_ALERT_KEY = 'focus_one_min_alert_enabled_v1';

    // 状態
    let state = 'home'; // 'home' | 'work' | 'break'
    let timerId = null;
    let remaining = 0;
    // 1分前アナウンス用のセッション情報
    let sessionTotalSec = 0;
    let oneMinuteAnnounced = false;
    let paused = false;
    let currentEntryId = null; // 編集中のID（新規なら null）
    let debounceSaveTimer = null;

    // 要素取得
    const $ = (sel) => document.querySelector(sel);
    const scrHome = $('#screen-home');
    const scrWork = $('#screen-work');
    const scrBreak = $('#screen-break');
    const timerWork = $('#timerWork');
    const timerBreak = $('#timerBreak');
    // アラート設定UI
    const oneMinAlertEl = $('#oneMinAlert');

    // 設定読み込み/初期化
    let oneMinuteAlertEnabled = (() => { try { const v = localStorage.getItem(ONE_MIN_ALERT_KEY); return v == null ? true : v === '1'; } catch { return true; } })();
    try { if (oneMinAlertEl) oneMinAlertEl.checked = !!oneMinuteAlertEnabled; } catch {}
    if (oneMinAlertEl) oneMinAlertEl.onchange = () => {
      oneMinuteAlertEnabled = !!oneMinAlertEl.checked;
      try { localStorage.setItem(ONE_MIN_ALERT_KEY, oneMinuteAlertEnabled ? '1' : '0'); } catch {}
    };
    const editor = $('#editor');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');
    const focusMsg = document.querySelector('#screen-work .focus-msg');
    const purposeInput = $('#purposeInput');
    const listSaved = $('#listSaved');
    const emptySaved = $('#emptySaved');
    const toast = $('#toast');
    const saveStatusEl = $('#saveStatus');
    const micStatus = $('#micStatus');
    const micInterim = $('#micInterim');
    const calmMsg = document.getElementById('calmMsg');
    const metricsEl = document.getElementById('metrics');
    const coachEl = $('#coach');
    const coachTips = ['誰に？', 'いつまでに？', '何を？', 'なぜ今？', '成功条件は？'];
    let lastInputAt = Date.now();
    let sessionStartAt = 0;
    let baselineChars = 0;
    let focusFoldTimer = null;
    const SESS_KEY = 'focus_sessions_v1';
    let coachRotateId = null;
    let coachShownAt = 0;
    const IDLE_MS = 12000; // 12s 無操作で表示
    const COACH_COOLDOWN_MS = 90000; // 90s クールダウン
    // Mic overlay / preferences
    const micOverlay = $('#micOverlay');
    const micOverlayStart = $('#micOverlayStart');
    const micAuto = $('#micAuto');
    const micPersist = $('#micPersist');
    const MIC_OK_KEY = 'focus_mic_ok';
    const MIC_AUTO_KEY = 'focus_mic_auto';

    const MIC_PERSIST_KEY = 'focus_mic_persist';
    function hideCoach() {
      if (coachEl) coachEl.style.display = 'none';
      if (coachRotateId) { clearInterval(coachRotateId); coachRotateId = null; }
    }
    function showCoach() {
      if (!coachEl) return;
      // すでに表示中ならスキップ
      if (coachEl.style.display !== 'none') return;
      // 音声入力中は出さない
      if (typeof srOn !== 'undefined' && srOn) return;
      coachShownAt = Date.now();
      let idx = 0;
      coachEl.textContent = coachTips[idx];
      coachEl.style.display = '';
      if (coachRotateId) clearInterval(coachRotateId);
      coachRotateId = setInterval(() => {
        idx = (idx + 1) % coachTips.length;
        coachEl.textContent = coachTips[idx];
      }, 3500);
      // 自動的に一定時間後に隠す（過干渉を避ける）
      setTimeout(() => hideCoach(), coachTips.length * 3500 + 1000);
    }

    // 読みやすさモード
    const readModal = $('#readModal');
    const readContent = $('#readContent');
    const readEmpty = $('#readEmpty');
    const READ_FS_KEY = 'focus_read_fs';
    const READ_LH_KEY = 'focus_read_lh';
    let readFs = parseInt(localStorage.getItem(READ_FS_KEY) || '18', 10);
    let readLh = parseFloat(localStorage.getItem(READ_LH_KEY) || '1.85');

    function applyReadPrefs() {
      if (readContent) {
        readContent.style.fontSize = Math.max(14, Math.min(28, readFs)) + 'px';
        readContent.style.lineHeight = Math.max(1.4, Math.min(2.2, readLh));
      }
    }
    function escapeHtmlStrict(s) {
      return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }
    function linkifyAndEscape(s) {
      const re = /(https?:\/\/[^\s]+)/g;
      let out = '';
      let last = 0; let m;
      while ((m = re.exec(s)) !== null) {
        out += escapeHtmlStrict(s.slice(last, m.index));
        const url = m[0];
        const safeUrl = escapeHtmlStrict(url);
        out += `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeUrl}</a>`;
        last = re.lastIndex;
      }
      out += escapeHtmlStrict(s.slice(last));
      return out;
    }
    function toParagraphs(raw) {
      if (!raw || !raw.trim()) return [];
      const s = raw.replace(/\r/g, '');
      const hasBlank = /\n{2,}/.test(s);
      if (hasBlank) {
        return s.split(/\n{2,}/).map(x => x.replace(/\n+/g, ' ').trim()).filter(Boolean);
      }
      // Fallback: 文末記号で段落化（後読み非依存）
      const sentences = (s.match(/[^。！？!?\n]+[。！？!?]?/g) || []).map(x => x.replace(/\n+/g, ' ').trim()).filter(Boolean);
      const paras = [];
      let buf = '';
      for (const sen of sentences) {
        buf += (buf ? ' ' : '') + sen;
        if (buf.length >= 60 || /[。！？!?]$/.test(sen)) {
          paras.push(buf); buf = '';
        }
      }
      if (buf) paras.push(buf);
      return paras;
    }
    function renderReadable(text) {
      const ps = toParagraphs(text);
      if (ps.length === 0) return '';
      return ps.map(p => `<p>${linkifyAndEscape(p)}</p>`).join('');
    }
    function openReadModalFromText(text) {
      const html = renderReadable(text);
      if (html) {
        readContent.innerHTML = html;
        readContent.style.display = '';
        readEmpty.style.display = 'none';
      } else {
        readContent.style.display = 'none';
        readEmpty.style.display = 'block';
      }
      applyReadPrefs();
      readModal.classList.add('show');
      try { const first = readModal.querySelector('#readClose, button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); if (first && first.focus) first.focus(); } catch {}
      if (typeof enableReadModalTrap === 'function') enableReadModalTrap();
    }
    function closeReadModal() { readModal.classList.remove('show'); }

    let readModalTrapHandler = null;
    function enableReadModalTrap() {
      disableReadModalTrap();
      readModalTrapHandler = function(e) {
        if (!readModal.classList.contains('show')) return;
        if (e.key !== 'Tab') return;
        const focusables = Array.from(readModal.querySelectorAll('a[href], area[href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex]:not([tabindex="-1"])'));
        if (focusables.length === 0) return;
        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        const active = document.activeElement;
        if (e.shiftKey) {
          if (active === first || !readModal.contains(active)) { e.preventDefault(); last.focus(); }
        } else {
          if (active === last || !readModal.contains(active)) { e.preventDefault(); first.focus(); }
        }
      };
      document.addEventListener('keydown', readModalTrapHandler, true);
    }
    function disableReadModalTrap() {
      if (readModalTrapHandler) { document.removeEventListener('keydown', readModalTrapHandler, true); readModalTrapHandler = null; }
    }
    (function(){
      const btn = document.getElementById('readClose');
      if (!btn) return;
      const old = btn.onclick;
      btn.onclick = function() { if (typeof old === 'function') old(); disableReadModalTrap(); };
    })();
    // テーマ切替
    const THEME_KEY = 'focus_theme_v1_theme';
    let currentTheme = (() => {
      try {
        const saved = localStorage.getItem(THEME_KEY);
        if (saved === 'light' || saved === 'dark') return saved;
      } catch {}
      return (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) ? 'light' : 'dark';
    })();

    function applyTheme(theme) {
      currentTheme = (theme === 'light') ? 'light' : 'dark';
      if (currentTheme === 'light') document.documentElement.setAttribute('data-theme', 'light');
      else document.documentElement.removeAttribute('data-theme');
      updateThemeUI();
    }
    function updateThemeUI() {
      const btn = document.querySelector('#btnTheme');
      if (!btn) return;
      btn.textContent = (currentTheme === 'light') ? '🌙 ダーク' : '☀️ ライト';
      btn.title = 'テーマ切替: 現在 ' + (currentTheme === 'light' ? 'ライト' : 'ダーク');
    }
    function toggleTheme() {
      const next = (currentTheme === 'light') ? 'dark' : 'light';
      try { localStorage.setItem(THEME_KEY, next); } catch {}
      applyTheme(next);
    }
    const btnTheme = $('#btnTheme');
    if (btnTheme) btnTheme.onclick = toggleTheme;
    applyTheme(currentTheme);

    // 画面切替
    function showScreen(name) {
      state = name;
      for (const el of document.querySelectorAll('.screen')) el.classList.remove('active');
      if (name === 'home') scrHome.classList.add('active');
      if (name === 'work') scrWork.classList.add('active');
      if (name === 'break') scrBreak.classList.add('active');
      if (name !== 'work') { stopMic(); hideCoach(); } // 画面遷移時に音声入力を停止/コーチ非表示
    }

    // ユーティリティ
    function fmt(sec) {
      const m = Math.floor(sec / 60).toString().padStart(2, '0');
      const s = Math.floor(sec % 60).toString().padStart(2, '0');
      return `${m}:${s}`;
    }
    let toastTimer = null;
    function toastShow(msg, ms = 2500) {
      toast.textContent = msg;
      toast.classList.add('show');
      if (toastTimer) { try { clearTimeout(toastTimer); } catch {} }
      toastTimer = setTimeout(() => { toast.classList.remove('show'); toastTimer = null; }, ms);
    }
    function updateFocusFromEditor(force = false) {
      try {
        const first = (editor.value.split(/\n/, 1)[0] || '').trim();
        const finished = editor.value.indexOf('\n') !== -1 || force;
        if (focusMsg) {
          if (finished && first) focusMsg.textContent = first;
          else focusMsg.textContent = '今は書くことだけ';
        }
      } catch {}
    }
    function currentChars() {
      try { return (editor.value || '').replace(/\n/g,'').length; } catch { return 0; }
    }
    function typedChars() {
      return Math.max(0, currentChars() - baselineChars);
    }
    
    // チャット入力 → 本文追記
    let chatComposing = false;
    function appendChatLine(text) {
      const t = String(text || '').trim();
      if (!t) return;
      try {
        let v = editor.value || '';
        if (v && !v.endsWith('\n')) v += '\n';
        editor.value = v + t + '\n';
        try { editor.dispatchEvent(new Event('input', { bubbles: true })); } catch {}
        try { requestAnimationFrame(() => { try { editor.scrollTop = editor.scrollHeight; } catch {} }); } catch {}

        lastInputAt = Date.now();
        hideCoach();
        updateFocusFromEditor(true);
        updateMetrics(Date.now());
      } catch {}
    }
    function updateMetrics(nowTs = Date.now()) {
      if (!metricsEl) return;
      const tc = typedChars();
      const elapsedSec = Math.max(1, Math.floor((nowTs - (sessionStartAt||nowTs)) / 1000));
      const wpm = Math.max(0, Math.round(tc / (elapsedSec/60)));
      metricsEl.textContent = `文字数 ${tc} | 文字/分 ${wpm}`;
    }
    function countTasksInText(s) {
      if (!s) return 0;
      const re = /^(?:\s*[-・・・]|\s*\d+[\.)]|\s*・)\s+/gm;
      const m = s.match(re);
      return m ? m.length : 0;
    }
    function saveSessionSummary(summary) {
      try {
        const all = JSON.parse(localStorage.getItem(SESS_KEY) || '[]');
        all.unshift(summary);
        localStorage.setItem(SESS_KEY, JSON.stringify(all));
      } catch {}
    }
    function pad2(n) { return n.toString().padStart(2,'0'); }
    function fmtJp(sec) {
      sec = Math.max(0, Math.floor(sec||0));
      const m = Math.floor(sec/60), s = sec % 60;
      return `${m}分${s}秒`;
    }
    function fmtYmdHm(ts) {
      const d = new Date(ts);
      const yyyy = d.getFullYear();
      const mm = pad2(d.getMonth()+1);
      const dd = pad2(d.getDate());
      const hh = pad2(d.getHours());
      const mi = pad2(d.getMinutes());
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }

    // ストレージ
    const LS_KEY = 'focus_entries_v1';
    function loadAll() {
      try { return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
      catch { return []; }
    }
    function saveAll(arr) {
      localStorage.setItem(LS_KEY, JSON.stringify(arr));
    }
    // 既存の upsertEntry はそのまま残し、マージ版を追加
    function upsertEntryMerged(entry) {
      const all = loadAll();
      if (!entry.id) entry.id = `e_${Date.now()}`;
      const i = all.findIndex(x => x.id === entry.id);
      if (i >= 0) {
        const prev = all[i];
        all[i] = { ...prev, ...entry, star: entry.star !== undefined ? entry.star : prev.star };
      } else {
        all.unshift(entry);
      }
      saveAll(all);
      return entry.id;
    }
    function upsertEntry(entry) {
      const all = loadAll();
      if (!entry.id) entry.id = `e_${Date.now()}`;
      const i = all.findIndex(x => x.id === entry.id);
      if (i >= 0) all[i] = entry; else all.unshift(entry);
      saveAll(all);
      return entry.id;
    }
    function deleteEntry(id) {
      const all = loadAll().filter(x => x.id !== id);
      saveAll(all);
    }
    // タグ抽出・スニペット
    function extractTags(text) {
      const tags = new Set();
      const re = /(^|\s)#([^\s#]{1,30})/g;
      let m; const s = text || '';
      while ((m = re.exec(s)) !== null) tags.add(m[2]);
      return Array.from(tags).slice(0, 12);
    }
    function snippet(text, limit = 140) {
      const t = (text || '').replace(/\s+/g, ' ').trim();
      return t.length > limit ? t.slice(0, limit) + '…' : t;
    }

    // フィルタ状態
    let filterStarOnly = false;
    let filterTag = null;
    function renderTagChips(all) {
      if (!tagChips) return;
      const counts = new Map();
      for (const e of all) {
        const ts = e.tags || extractTags(e.text || '');
        for (const t of ts) counts.set(t, (counts.get(t) || 0) + 1);
      }
      const top = Array.from(counts.entries()).sort((a,b)=>b[1]-a[1]).slice(0, 10);
      tagChips.innerHTML = '';
      for (const [t,c] of top) {
        const chip = document.createElement('button');
        chip.className = 'chip' + (filterTag === t ? ' active' : '');
        chip.textContent = `#${t} (${c})`;
        chip.onclick = () => { filterTag = (filterTag === t ? null : t); refreshList2(); };
        tagChips.appendChild(chip);
      }
    }
    // 改良版リスト更新
    function refreshList2() {
      const all = loadAll();
      for (const e of all) { if (!e.tags) e.tags = extractTags(e.text || ''); }
      const q = (searchInput && searchInput.value || '').trim();
      const qLower = q.toLowerCase();
      let filtered = all.filter(e => {
        if (filterStarOnly && !e.star) return false;
        if (filterTag && !(e.tags || []).includes(filterTag)) return false;
        if (!q) return true;
        const hay = `${e.title || ''}\n${e.text || ''}\n${(e.tags||[]).map(t=>`#${t}`).join(' ')}`;
        return hay.toLowerCase().includes(qLower);
      });
      filtered.sort((a,b)=>((b.star?1:0)-(a.star?1:0)) || (b.ts||0)-(a.ts||0));

      renderTagChips(all);

      listSaved.innerHTML = '';
      if (filtered.length === 0) {
        emptySaved.style.display = 'block';
        return;
      }
      emptySaved.style.display = 'none';
      for (const e of filtered) {
        const li = document.createElement('li');
        li.className = 'entry-card';
        // Title / meta / preview
        const titleBtn = document.createElement('button');
        titleBtn.className = 'entry-title title-btn';
        titleBtn.textContent = e.title || '(無題)';
        titleBtn.title = '開く';
        titleBtn.onclick = () => {
          editor.value = e.text || '';
          currentEntryId = e.id;
          startWork(true);
        };
        const metaEl = document.createElement('div'); metaEl.className = 'entry-meta muted';
        const dTxt = fmtYmdHm(e.ts || Date.now());
        const durStr = (e.durationSec != null) ? fmtJp(e.durationSec) : '';
        const chars = (typeof e.chars === 'number') ? e.chars : (e.text ? e.text.replace(/\n/g,'').length : 0);
        metaEl.textContent = `${dTxt} | ${durStr || '0分0秒'} | 文字数 ${chars}`;
        const snipEl = document.createElement('div'); snipEl.className = 'entry-preview'; snipEl.textContent = snippet(e.text || '', 140);
        li.appendChild(titleBtn); li.appendChild(metaEl); li.appendChild(snipEl);
        if ((e.tags || []).length) {
          const tw = document.createElement('div');
          for (const t of e.tags) { const chip = document.createElement('span'); chip.className = 'chip'; chip.style.fontSize = '11px'; chip.textContent = `#${t}`; chip.onclick = () => { filterTag = t; refreshList2(); }; tw.appendChild(chip); }
          li.appendChild(tw);
        }
        // Actions (top-right)
        const actions = document.createElement('div');
        actions.className = 'entry-actions';
        // star toggle
        const starBtn = document.createElement('button');
        starBtn.className = 'icon-btn star-btn' + (e.star ? ' is-starred' : '');
        starBtn.textContent = e.star ? '★' : '☆';
        starBtn.title = e.star ? 'スターを外す' : 'スターを付ける';
        starBtn.onclick = () => { e.star = !e.star; upsertEntryMerged(e); refreshList2(); };
        // delete
        const delBtn = document.createElement('button');
        delBtn.className = 'icon-btn del-btn';
        delBtn.textContent = '🗑';
        delBtn.title = '削除';
        delBtn.onclick = () => { if (confirm('削除しますか？')) { deleteEntry(e.id); refreshList2(); } };
        actions.appendChild(starBtn);
        actions.appendChild(delBtn);
        li.appendChild(actions);
        listSaved.appendChild(li);
      }
    }
    function refreshList() {
      const all = loadAll();
      listSaved.innerHTML = '';
      if (all.length === 0) {
        emptySaved.style.display = 'block';
        return;
      }
      emptySaved.style.display = 'none';
      for (const e of all) {
        const li = document.createElement('li');
        li.className = 'entry-card';
        // Title / meta / preview
        const titleBtn = document.createElement('button'); titleBtn.className = 'entry-title title-btn';
        titleBtn.textContent = e.title || '(無題)';
        titleBtn.title = '開く';
        titleBtn.onclick = () => { editor.value = e.text || ''; currentEntryId = e.id; startWork(true); };
        const metaEl = document.createElement('div'); metaEl.className = 'entry-meta muted';
        const chars2 = (typeof e.chars === 'number') ? e.chars : (e.text ? e.text.replace(/\n/g,'').length : 0);
        metaEl.textContent = `${fmtYmdHm(e.ts || Date.now())} | ${fmtJp(e.durationSec||0)} | 文字数 ${chars2}`;
        const snipEl = document.createElement('div'); snipEl.className = 'entry-preview'; snipEl.textContent = snippet(e.text || '', 140);
        li.appendChild(titleBtn); li.appendChild(metaEl); li.appendChild(snipEl);
        // Actions (top-right)
        const actions = document.createElement('div'); actions.className = 'entry-actions';
        const starBtn = document.createElement('button'); starBtn.className = 'icon-btn star-btn' + (e.star ? ' is-starred' : '');
        starBtn.textContent = e.star ? '★' : '☆'; starBtn.title = e.star ? 'スターを外す' : 'スターを付ける';
        starBtn.onclick = () => { e.star = !e.star; upsertEntryMerged(e); refreshList(); };
        const delBtn = document.createElement('button'); delBtn.className = 'icon-btn del-btn'; delBtn.textContent = '🗑'; delBtn.title = '削除';
        delBtn.onclick = () => { if (confirm('削除しますか？')) { deleteEntry(e.id); refreshList(); } };
        actions.appendChild(starBtn);
        actions.appendChild(delBtn);
        li.appendChild(actions);
        listSaved.appendChild(li);
      }
    }
    function escapeHtml(s) {
      return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }

    // タイマー
    function clearTimer() { if (timerId) { clearInterval(timerId); timerId = null; } }

    function startWork(startCountdown = true) {
      showScreen('work');
      clearTimer();
      paused = false;
      const total = DEV ? 25 : workMinutes * 60;
      remaining = total;
      sessionTotalSec = total;
      oneMinuteAnnounced = false;
      timerWork.textContent = fmt(remaining);
      const cm = document.getElementById('calmMsg');
      if (cm) cm.textContent = `残り ${fmt(remaining)} — 深呼吸して続けよう`;
      // metrics baseline
      sessionStartAt = Date.now();
      baselineChars = currentChars();
      updateMetrics(sessionStartAt);
      // Focus heading fold after 30s（自動折りたたみ）
      try { if (focusFoldTimer) clearTimeout(focusFoldTimer); } catch {}
      const fm = document.querySelector('#screen-work .focus-msg');
      if (fm) fm.style.display = ''; // セッション開始時に再表示
      focusFoldTimer = setTimeout(() => { if (fm) fm.style.display = 'none'; }, 30000);
      updateFocusFromEditor();
      if (startCountdown) runCountdown('work');
    }

    function startBreak() {
      showScreen('break');
      clearTimer();
      paused = false;
      remaining = BREAK_SEC;
      sessionTotalSec = BREAK_SEC;
      oneMinuteAnnounced = false;
      timerBreak.textContent = fmt(remaining);
      runCountdown('break');
    }

    let lastCalmMin = null;
    let lastCalmPhrase = '深呼吸して続けよう';
    const calmPhrases = ['深呼吸して続けよう','一歩ずついこう','そのまま書いてOK','手を止めずに','良いペース'];
    function updateCalm(remainingSec) {
      const cm = document.getElementById('calmMsg');
      if (!cm) return;
      const mm = Math.floor(Math.max(0, remainingSec)/60);
      if (lastCalmMin !== mm) {
        lastCalmMin = mm;
        lastCalmPhrase = calmPhrases[mm % calmPhrases.length];
      }
      cm.textContent = `残り ${fmt(remainingSec)} — ${lastCalmPhrase}`;
    }

    function playBeep() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 pitch
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5); // Play for 0.5 seconds
      } catch (e) {
        console.error('Could not play beep sound', e);
      }
    }

    // 簡易TTS（Web Speech API）。利用不可ならビープにフォールバック。
    function speak(text) {
      try {
        const synth = window.speechSynthesis;
        if (synth && typeof SpeechSynthesisUtterance !== 'undefined') {
          const uttr = new SpeechSynthesisUtterance(text);
          uttr.lang = 'ja-JP';
          uttr.rate = 1.0;
          uttr.pitch = 1.0;
          synth.speak(uttr);
          return;
        }
      } catch (e) { /* noop */ }
      // フォールバック: ビープ音
      playBeep();
    }


    function runCountdown(kind) {
      const tick = () => {
        if (paused) return;
        remaining -= 1;
        if (kind === 'work') { const r = Math.max(0, remaining); timerWork.textContent = fmt(r); updateCalm(r); updateMetrics(); }
        if (kind === 'break') timerBreak.textContent = fmt(Math.max(0, remaining));

        // 終了1分前の音声アナウンス（セッションあたり一度だけ）
        try {
          const r = Math.max(0, remaining);
          const threshold = ONE_MIN_ALERT_THRESHOLD;
          if (oneMinuteAlertEnabled && !oneMinuteAnnounced && sessionTotalSec >= threshold && r === threshold) {
            oneMinuteAnnounced = true;
            speak(kind === 'work' ? '残り1分です。あと少し集中しましょう。' : '休憩はあと1分で終わります。');
          }
        } catch (e) { /* noop */ }
        if (remaining <= 0) {
          clearTimer();
          playBeep();
          if (kind === 'work') {
            saveWork(true); // Auto-save here
            // compute session summary
            const elapsedSec = Math.max(1, Math.floor((Date.now() - (sessionStartAt||Date.now()))/1000));
            const chars = typedChars();
            const avgWpm = Math.max(0, Math.round(chars / (elapsedSec/60)));
            const tasks = countTasksInText(editor.value || '');
            saveSessionSummary({ ts: Date.now(), minutes: workMinutes, secs: elapsedSec, chars, wpm: avgWpm, tasks });
            // 区切りのダイアログを先に表示し、閉じたら休憩へ
            celebrateNext = () => { startBreak(); };
            showCelebrate();
          } else {
            toastShow('よく頑張った！');
            showScreen('home');
          }
        }
      };
      // 1秒毎
      timerId = setInterval(tick, 1000);
    }

    function updateSaveStatus() {
      if (!saveStatusEl) return;
      const now = new Date();
      const year = now.getFullYear();
      const month = (now.getMonth() + 1).toString().padStart(2, '0');
      const day = now.getDate().toString().padStart(2, '0');
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const seconds = now.getSeconds().toString().padStart(2, '0');
      const dateTimeString = `${year}年${month}月${day}日 ${hours}時${minutes}分${seconds}秒`;
      saveStatusEl.textContent = `保存済: ${dateTimeString}`;
      saveStatusEl.style.opacity = '0.6';
    }

    function saveWork(isAuto = false) {
      const text = editor.value || '';
      if (!text) return; // Don't save if empty
      const firstLine = (text.split(/\n/, 1)[0] || '').trim();
      const title = firstLine || '（無題）';
      // 既存とマージ（より長い方を保持）
      let prevDur = 0;
      if (currentEntryId) {
        try {
          const prev = (loadAll() || []).find(x => x.id === currentEntryId);
          if (prev && typeof prev.durationSec === 'number') prevDur = prev.durationSec;
        } catch {}
      }
      const total = DEV ? 25 : workMinutes * 60;
      const entry = { id: currentEntryId, title, text, ts: Date.now(), durationSec: Math.max(prevDur, Math.max(0, total - remaining)), chars: text.replace(/\n/g,'').length };
      // タグ抽出を加え、スターは維持
      entry.tags = extractTags(text);
      currentEntryId = upsertEntryMerged(entry);
      if (!isAuto) {
        toastShow('保存しました');
      }
      refreshList2();
      updateSaveStatus();
    }

    // イベント
    const btnHomeEl = $('#btnHome');
    if (btnHomeEl) btnHomeEl.onclick = () => { clearTimer(); showScreen('home'); refreshList2(); };
    const brandHome = document.querySelector('#brandHome');
    if (brandHome) brandHome.onclick = (e) => { e.preventDefault(); clearTimer(); showScreen('home'); refreshList2(); };
    $('#btnBackHome').onclick = () => { clearTimer(); showScreen('home'); refreshList2(); };

    function startNewSession() {
      currentEntryId = null;
      const goal = (purposeInput && purposeInput.value.trim()) || '';
      const baseText = goal ? (goal + "\n\n") : '';
      editor.value = baseText;
      try { if (purposeInput) purposeInput.blur(); } catch {}
      startWork(true);
      editor.focus();
      editor.selectionStart = editor.selectionEnd = editor.value.length; // 入力は3行目から
      updateFocusFromEditor(true);
      if (goal) {
        const cleanupStart = Date.now();
        setTimeout(() => {
          try {
            const current = editor.value || '';
            if (!current.startsWith(baseText)) return;
            const tail = current.slice(baseText.length);
            if (!tail) return;
            if (tail.includes('\n')) return;
            if (tail.length > 2) return;
            if (!goal.endsWith(tail)) return;
            if (Date.now() - cleanupStart > 200) return;
            editor.value = baseText;
            editor.selectionStart = editor.selectionEnd = baseText.length;
            updateFocusFromEditor(true);
          } catch {}
        }, 0);
      }
    }

    $('#btnStart').onclick = startNewSession;

    if (purposeInput) {
      purposeInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          startNewSession();
        }
      });
    }
    $('#btnPause').onclick = () => { paused = !paused; $('#btnPause').textContent = paused ? '再開' : '一時停止'; };
    $('#btnReset').onclick = () => { if (state === 'work') startWork(false); if (state === 'break') startBreak(); };
    $('#btnSkipBreak').onclick = () => { clearTimer(); toastShow('休憩をスキップしました'); showScreen('home'); };

    $('#btnSave').onclick = () => saveWork(false);

    // 読みやすさモード: ヘッダーのボタン
    const btnReadMode = $('#btnReadMode');
    if (btnReadMode) btnReadMode.onclick = () => { openReadModalFromText(editor.value || ''); };

    // 読みやすさモード: コントロール
    $('#readClose').onclick = closeReadModal;
    $('#readDec').onclick = () => { readFs = Math.max(14, readFs - 1); localStorage.setItem(READ_FS_KEY, String(readFs)); applyReadPrefs(); };
    $('#readInc').onclick = () => { readFs = Math.min(28, readFs + 1); localStorage.setItem(READ_FS_KEY, String(readFs)); applyReadPrefs(); };
    $('#readLh').onclick = () => {
      const steps = [1.6, 1.75, 1.85, 2.0];
      const idx = Math.max(0, steps.findIndex(x => Math.abs(x - readLh) < 0.001));
      readLh = steps[(idx + 1) % steps.length];
      localStorage.setItem(READ_LH_KEY, String(readLh));
      applyReadPrefs();
    };
    // 背景クリック/ESCで閉じる
    readModal.addEventListener('click', (e) => { if (e.target === readModal) closeReadModal(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && readModal.classList.contains('show')) closeReadModal(); });

    // タブ非アクティブ時は自動一時停止、復帰で再開
    let autoPaused = false;
    document.addEventListener('visibilitychange', () => {
      if (state === 'work' || state === 'break') {
        const pauseBtn = document.querySelector('#btnPause');
        if (document.visibilityState === 'hidden') {
          if (!paused) { paused = true; autoPaused = true; if (pauseBtn) pauseBtn.textContent = '再開'; }
        } else {
          if (autoPaused) { paused = false; autoPaused = false; if (pauseBtn) pauseBtn.textContent = '一時停止'; }
        }
      }
    });

    // 音声入力（作り直し版: シンプルな状態管理）
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    const srSupported = !!SR;
    let sr = null;
    let srOn = false;

    class SimpleSR {
      constructor({ lang = 'ja-JP', onFinal, onInterim, onStart, onEnd, onError, autoRestart = true }) {
        this.lang = lang;
        this.onFinal = onFinal;
        this.onInterim = onInterim;
        this.onStart = onStart;
        this.onEnd = onEnd;
        this.onError = onError;
        this.rec = null;
        this.autoRestart = autoRestart;
        this._stopping = false;
      }
      start() {
        if (!SR) throw new Error('unsupported');
        if (this.rec) return; // already running
        const r = new SR();
        r.lang = this.lang;
        r.continuous = true;
        r.interimResults = true;
        r.maxAlternatives = 1;
        r.onstart = () => this.onStart && this.onStart();
        r.onresult = (e) => {
          let interim = '';
          for (let i = e.resultIndex; i < e.results.length; i++) {
            const res = e.results[i];
            const txt = (res[0] && res[0].transcript) || '';
            if (res.isFinal) this.onFinal && this.onFinal(txt.trim());
            else interim += txt;
          }
          this.onInterim && this.onInterim(interim.trim());
        };
        r.onerror = (e) => {
          const er = (e && e.error) ? e.error : 'unknown';
          if (['not-allowed','service-not-allowed','audio-capture','network'].includes(er)) { this._stopping = true; }
          this.onError && this.onError(er);
        };
        r.onend = () => {
          const shouldRestart = this.autoRestart && !this._stopping;
          this.onEnd && this.onEnd();
          this.rec = null;
          if (shouldRestart) {
            setTimeout(() => { try { this.start(); } catch (e) {} }, 250);
          }
          this._stopping = false;
        };
        this.rec = r;
        r.start();
      }
      stop() {
        if (!this.rec) return;
        this._stopping = true;
        try { this.rec.abort(); } catch {}
        this.rec = null;
      }
    }

    function appendToEditor(text) {
      if (!text) return;
      const last = editor.value.slice(-1);
      const startsWithPunctOrNl = /^[\n、。！？!?））」』】\s]/.test(text);
      let joiner = '';
      if (editor.value && !editor.value.endsWith('\n')) {
        if (startsWithPunctOrNl) {
          if (last === ' ') editor.value = editor.value.slice(0, -1);
        } else {
          joiner = ' ';
        }
      }
      editor.value = editor.value + joiner + text;
      editor.selectionStart = editor.selectionEnd = editor.value.length;
    }

    function normalizeDictation(s) {
      let t = String(s || '').trim();
      if (!t) return '';
      const repl = [
        [/だんらく|段落/g, '\n\n'],
        [/改行|かいぎょう/g, '\n'],
        [/句点|まる/g, '。'],
        [/てん/g, '、'],
        [/感嘆符|びっくり|ビックリ/g, '！'],
        [/はてな|クエスチョン/g, '？'],
        [/中黒/g, '・'],
        [/コロン/g, '：'],
        [/セミコロン/g, '；']
      ];
      for (const [re, rep] of repl) t = t.replace(re, rep);
      return t;
    }

    function updateMicUI() {
      const btn = $('#btnMic');
      if (!srSupported) {
        btn.disabled = true;
        btn.title = 'このブラウザは音声入力に対応していません';
        return;
      }
      btn.textContent = srOn ? '🎤 音声入力停止' : '🎤 音声入力開始';
    }

    function startMic() {
      if (!srSupported) return alert('このブラウザは音声入力に対応していません');
      if (!sr) sr = new SimpleSR({
        autoRestart: (function(){ try { const v = localStorage.getItem(MIC_PERSIST_KEY); return (v === null || v === '1'); } catch { return true; } })(),
        lang: 'ja-JP',
        onStart: () => { srOn = true; try{ localStorage.setItem(MIC_OK_KEY,'1'); }catch{} micStatus.style.display = 'block'; micStatus.textContent = '音声入力中…'; updateMicUI(); },
        onEnd: () => { },
        onInterim: (tmp) => { if (tmp) { micInterim.style.display = 'block'; micInterim.textContent = '聞き取り中: ' + tmp; } else { micInterim.style.display = 'none'; } },
        onFinal: (txt) => appendToEditor(normalizeDictation(txt)),
        onError: (err) => { const fatal = ['not-allowed','service-not-allowed','audio-capture','network']; if (err === 'no-speech' || err === 'aborted') return; if (fatal.includes(err)) { try { stopMic(); } catch {} srOn = false; updateMicUI(); toastShow('マイクエラー: ' + err); return; } srOn = false; updateMicUI(); toastShow('音声入力エラー: ' + err); }
      });
      try { sr.start(); editor.focus(); } catch (e) { toastShow('音声入力を開始できませんでした'); }
      updateMicUI();
    }
    function stopMic() {
      if (sr) sr.stop();
      srOn = false;
      micStatus.style.display = 'none';
      micInterim.style.display = 'none';
      updateMicUI();
    }
    // 入力監視: 無操作でコーチ表示 & 自動保存
    editor.addEventListener('input', () => {
      lastInputAt = Date.now();
      hideCoach();
      updateFocusFromEditor();

      if (debounceSaveTimer) {
        clearTimeout(debounceSaveTimer);
      }
      debounceSaveTimer = setTimeout(() => {
        saveWork(true);
      }, 3000);
    });

    $('#btnMic').onclick = () => { if (!srOn) startMic(); else stopMic(); };

    if (chatInput) {
      chatInput.addEventListener('compositionstart', () => { chatComposing = true; });
      chatInput.addEventListener('compositionend', () => { chatComposing = false; });
      chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !chatComposing) {
          e.preventDefault();
          appendChatLine(chatInput.value);
          chatInput.value = '';
          try { chatInput.focus(); } catch {}
        }
      });
    }
    if (chatSend) chatSend.onclick = () => { appendChatLine(chatInput && chatInput.value); if (chatInput) { chatInput.value = ''; try { chatInput.focus(); } catch {} } };
    updateMicUI();

    // Mic quick-start helpers
    function showMicOverlay() { if (micOverlay) micOverlay.style.display = 'flex'; try { if (micAuto) micAuto.checked = (localStorage.getItem(MIC_AUTO_KEY) === '1'); if (micPersist) { const v = localStorage.getItem(MIC_PERSIST_KEY); micPersist.checked = (v === null || v === '1'); } } catch {} }
    function hideMicOverlay() { if (micOverlay) micOverlay.style.display = 'none'; }
    async function ensureMicPermission() {
      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return true; // best effort
        const s = await navigator.mediaDevices.getUserMedia({ audio: true });
        s.getTracks().forEach(t=>t.stop());
        try { localStorage.setItem(MIC_OK_KEY, '1'); } catch {}
        return true;
      } catch (e) {
        return false;
      }
    }
    function attemptAutoMicStart() {
      const ok = (()=>{ try { return localStorage.getItem(MIC_OK_KEY) === '1'; } catch { return false; } })();
      const auto = (()=>{ try { return localStorage.getItem(MIC_AUTO_KEY) === '1'; } catch { return false; } })();
      if (auto && ok) { startMic(); }
      else { showMicOverlay(); }
    }
    if (micOverlayStart) micOverlayStart.onclick = async () => {
      const granted = await ensureMicPermission();
      if (!granted) { toastShow('マイクの許可が必要です'); return; }
      if (micAuto) { try { localStorage.setItem(MIC_AUTO_KEY, micAuto.checked ? '1' : '0'); } catch {} }
      if (micPersist) { try { localStorage.setItem(MIC_PERSIST_KEY, micPersist.checked ? '1' : '0'); } catch {} }
      hideMicOverlay();
      startMic();
    };
    editor.addEventListener('focus', hideMicOverlay);
    if (chatInput) { chatInput.addEventListener('focus', hideMicOverlay); chatInput.addEventListener('input', hideMicOverlay); }
    editor.addEventListener('input', hideMicOverlay);

    // 快速トグル: キーボード M で音声入力トグル
    document.addEventListener('keydown', (e) => {
      const tag = (e.target && e.target.tagName) || '';
      const editable = (tag === 'INPUT' || tag === 'TEXTAREA' || (e.target && e.target.isContentEditable));
      if (editable || e.isComposing) return;
      if (e.key && e.key.toLowerCase() === 'm' && state === 'work' && !e.metaKey && !e.ctrlKey && !e.altKey) {
        e.preventDefault(); if (!srOn) startMic(); else stopMic();
      }
    });

    // 達成ダイアログ（静かな表示）
    const celebrate = document.querySelector('#celebrate');
    const celebrateClose = document.querySelector('#celebrateClose');
    let celebrateNext = null;
    function showCelebrate() {
      if (!celebrate) return;
      celebrate.style.display = 'flex';
      const title = document.getElementById('celebrateTitle');
      const body = document.getElementById('celebrateBody');
      if (title) title.textContent = 'よく頑張った！';
      if (body) {
        const elapsedSec = Math.max(1, Math.floor((Date.now() - (sessionStartAt||Date.now()))/1000));
        const chars = typedChars();
        const avgWpm = Math.max(0, Math.round(chars / (elapsedSec/60)));
        const tasks = countTasksInText(editor.value || '');
        body.textContent = `${workMinutes}分の集中 / 合計 ${chars} 文字・平均 文字/分 ${avgWpm}・タスク ${tasks}`;
      }
    }
    if (celebrateClose) celebrateClose.onclick = () => {
      celebrate.style.display = 'none';
      if (typeof celebrateNext === 'function') { const fn = celebrateNext; celebrateNext = null; fn(); }
    };

    // 検索/フィルタ
    if (searchInput) searchInput.addEventListener('input', () => refreshList2());
    if (btnStarFilter) btnStarFilter.onclick = () => {
      filterStarOnly = !filterStarOnly;
      btnStarFilter.textContent = filterStarOnly ? '★ スターのみ' : '☆ すべて';
      refreshList2();
    };

    // Fullscreen mode
    const btnFullscreen = document.getElementById('btnFullscreen');
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
        document.body.classList.add('body-fullscreen');
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
        document.body.classList.remove('body-fullscreen');
      }
    }
    if (btnFullscreen) {
      btnFullscreen.onclick = toggleFullscreen;
    }
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        document.body.classList.remove('body-fullscreen');
      }
    });

    // 初期化
    updateModeUI();
    refreshList2();
  </script>
</body>
</html>
